/*!
 *****************************************************************************
 @file:    adi_i2c_v1.h
 @brief:   I2C device driver definitions
 @details  This is the primary header file for the I2C driver, which contains the
           API declarations, data and constant definitions used in the APIs.
 @version: $Revision: 33422 $
 @date:    $Date: 2016-02-04 07:42:05 -0500 (Thu, 04 Feb 2016) $
 -----------------------------------------------------------------------------
Copyright (c) 2014 Analog Devices, Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:
  - Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
  - Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
  - Modified versions of the software must be conspicuously marked as such.
  - This software is licensed solely and exclusively for use with processors
    manufactured by or for Analog Devices, Inc.
  - This software may not be combined or merged with other code in any manner
    that would cause the software to become subject to terms and conditions
    which differ from those listed here.
  - Neither the name of Analog Devices, Inc. nor the names of its
    contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.
  - The use of this software may or may not infringe the patent rights of one
    or more patent holders.  This license does not release you from the
    requirement that you obtain separate licenses from these patent holders
    to use this software.
THIS SOFTWARE IS PROVIDED BY ANALOG DEVICES, INC. AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, NON-
INFRINGEMENT, TITLE, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL ANALOG DEVICES, INC. OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, PUNITIVE OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, DAMAGES ARISING OUT OF
CLAIMS OF INTELLECTUAL PROPERTY RIGHTS INFRINGEMENT; PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
*****************************************************************************/

#ifndef __ADI_I2C_V1_H__
#define __ADI_I2C_V1_H__

/** @addtogroup I2C_Driver I2C Device Driver
 *  @{
 */
#include <adi_types.h>
#include <services/int/adi_int.h>
#include <services/pwr/adi_pwr.h>
#include <adi_i2c_config.h>

#if defined (__ADUCM30xx__)
#else
#error "Unknown processor family"
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*! A device handle used in all API functions to identify the I2C device. */
typedef void *ADI_I2C_HANDLE;

/*! The amount of application supplied memory required by the I2C driver. */
#if (ADI_I2C_CFG_ENABLE_DMA_SUPPORT == 1)
#if (ADI_CFG_ENABLE_RTOS_SUPPORT == 1)
#define ADI_I2C_MEMORY_SIZE (288u)
#else
#define ADI_I2C_MEMORY_SIZE (224u)
#endif
#else
#if (ADI_CFG_ENABLE_RTOS_SUPPORT == 1)
#define ADI_I2C_MEMORY_SIZE (184u)
#else
#define ADI_I2C_MEMORY_SIZE (120u)
#endif
#endif

/*! Bit Mask for the different global events that can occur */
typedef enum {
    ADI_I2C_GLOBAL_EVENT_NONE                 = 0x0000,     /*!< No global event happened */
    ADI_I2C_GLOBAL_EVENT_GC_RESET_PRGN_ADDR   = 0x0001,     /*!< A reset and program address general call occurred */
    ADI_I2C_GLOBAL_EVENT_GC_PRGN_ADDR         = 0x0002,     /*!< A program address general call occurred */
    ADI_I2C_GLOBAL_EVENT_GC_HARDWARE          = 0x0004,     /*!< Hardware general call occurred */
    ADI_I2C_GLOBAL_EVENT_REP_START            = 0x0010      /*!< A repeat start general call occurred */
} ADI_I2C_GLOBAL_EVENT;


/**
 * Result codes generated by the I2C driver.
 */
typedef enum
{
    ADI_I2C_SUCCESS = 0,                          /*!< The API call succeeded. */
    ADI_I2C_FAILURE,                              /*!< The API call failed. */
    ADI_I2C_ERR_RTOS,                             /*!< Error Occurred in RTOS functions */
    ADI_I2C_INVALID_PARAMETER,                    /*!< And invalid parameter is passed to the function */
    ADI_I2C_BAD_DEVICE_NUMBER,                    /*!< The device number is invalid. */
    ADI_I2C_MODE_NOT_SUPPORTED,                   /*!< The operating mode is invalid. */
    ADI_I2C_INSUFFICIENT_MEMORY,                  /*!< The application supplied memory size is insufficient. */
    ADI_I2C_DEVICE_BUSY,                          /*!< The device is not in the idle state. */
    ADI_I2C_DEVICE_IN_USE,                        /*!< The device is in use. */
    ADI_I2C_BAD_DEVICE_HANDLE,                    /*!< The device handle is invalid. */
    ADI_I2C_DEVICE_NOT_OPEN,                      /*!< The device is not open. */
    ADI_I2C_BAD_BITRATE,                          /*!< The bit rate is invalid. */
    ADI_I2C_BAD_DUTYCYCLE,                        /*!< The duty cycle is invalid. */
    ADI_I2C_BAD_DATAWIDTH,                        /*!< The data width is invalid. */
    ADI_I2C_BUFFER_NOT_AVAILABLE,                 /*!< A descriptor is not available to store the given buffer. */
    ADI_I2C_ARBITRATION_LOST,                     /*!< Arbitration is Lost */
    ADI_I2C_NACK_ADDR,                            /*!< An no-acknowledgement occurred for the address */
    ADI_I2C_NACK_DATA,                            /*!< An no-acknowledgement occurred for the data */
    ADI_I2C_BLOCKING_MODE_INVALID,                /*!< The blocking mode is invalid for this API. */
    ADI_I2C_SEMAPHORE_FAILED,                     /*!< The OSAL returned an error. */
    ADI_I2C_DMA_ERROR,                            /*!< A DMA error occurred */
    ADI_I2C_GLOBAL_EVENT_OCCURRED,                /*!< A global event occurred */
    ADI_I2C_DIFF_BUFFER_TYPE_AVAILABLE,           /*!< A different buffer type than the requested type is available */
    ADI_I2C_PARTIAL_BUFFER                        /*!< The buffer is not fully filled */

} ADI_I2C_RESULT;

/**
 * The I2C driver operating modes.
 */
typedef enum
{
    ADI_I2C_MASTER,                       /*!< Master I2C device. */
    ADI_I2C_SLAVE                         /*!< Slave I2C device. */
} ADI_I2C_MODE;

/*! I2C Event Enums */
typedef enum
{
	ADI_I2C_EVENT_XMT_PROCESSED,           /*!< A transmit buffer completed processing. */
	ADI_I2C_EVENT_RCV_PROCESSED,           /*!< A receive buffer completed processing. */
    ADI_I2C_EVENT_PARTIAL_XMT_PROCESSED,   /*!< Transmit buffer is processed partially */
    ADI_I2C_EVENT_PARTIAL_RCV_PROCESSED,   /*!< Receive buffer is processed partially */
    ADI_I2C_EVENT_GCALL,                   /*!< General call event occurred */
    ADI_I2C_EVENT_REP_START,               /*!< Repeated start event occurred */
	ADI_I2C_EVENT_DNAK,                    /*!< The transfer was aborted due to the detection of a NAK during data transmission. */
	ADI_I2C_EVENT_ANAK,                    /*!< The transfer was aborted due to the detection of a NAK during the address phase of the transfer. */
	ADI_I2C_EVENT_LOSTARB,                 /*!< The current transfer was aborted due to the loss of arbitration with another master. */
}ADI_I2C_EVENT;

/*! Enum to distinguish the different general call event occurred.
 *  This is passed as argument with the ADI_I2C_EVENT_GCALL event callback call
 */
typedef enum {
    ADI_I2C_GCALL_RESET_PRGM_ADDR = 1,      /*!< Reset and program address general call occurred */
    ADI_I2C_GCALL_PRGM_ADDR       = 2,      /*!< Program address general call occurred */
    ADI_I2C_GCALL_HARDWARE        = 3       /*!< Hardware general call occurred */
} ADI_I2C_GCALL;

/*! I2C Device address width constants */
typedef enum
{
    ADI_I2C_HWADDR_WIDTH_7_BITS = 0,        /*!< The address width is 7 bits */
    ADI_I2C_HWADDR_WIDTH_10_BITS            /*!< The address width is 10 btis */
} ADI_I2C_HWADDR_WIDTH;


/*
 * Open a I2C device instance.
 */
ADI_I2C_RESULT adi_i2c_Open(
	uint32_t               const  DeviceNum,
	ADI_I2C_MODE           const  eMode,
	void                 * const  pMemory,
	uint32_t               const  MemorySize,
	ADI_I2C_HANDLE       * const  phDevice
);

/*
 * Close the given I2C device.
 */
ADI_I2C_RESULT adi_i2c_Close(
    ADI_I2C_HANDLE         const hDevice
);

/*
 * Register an application defined callback function.
 */
ADI_I2C_RESULT adi_i2c_RegisterCallback(
    ADI_I2C_HANDLE         const hDevice,
    ADI_CALLBACK           pfCallback,
    void                  *pCBParam);

/*
 * Write data to a I2C device (non-blocking).
 */
ADI_I2C_RESULT adi_i2c_SubmitTxBuffer(
    ADI_I2C_HANDLE         const hDevice,
    void                        *pBuffer,
    uint32_t               const nBufSize,
    bool_t                 const bRestart
);

/*
 * Read data from a I2C device (non-blocking).
 */
ADI_I2C_RESULT adi_i2c_SubmitRxBuffer(
    ADI_I2C_HANDLE         const hDevice,
    void                        *pBuffer,
    uint32_t               const nBufSize,
    bool_t                 const bRestart
);

/*
 * Checks if the Rx Buffer is available for processing.
 */
ADI_I2C_RESULT adi_i2c_IsRxBufferAvailable(
	    ADI_I2C_HANDLE         const hDevice,
	    bool_t*                const pbAvailable
);

/*
 * Checks if the Tx Buffer is available for processing.
 */
ADI_I2C_RESULT adi_i2c_IsTxBufferAvailable(
	    ADI_I2C_HANDLE   const hDevice,
	    bool_t*          const pbAvailable
);

/*
 * This will return the Rx buffer if a filled buffer is available,
 * otherwise waits until a buffer is filled.
 */
ADI_I2C_RESULT adi_i2c_GetRxBuffer (
                    ADI_I2C_HANDLE   const   hDevice,
                    void                   **ppBuffer
);

/*
 * This will return the Rx buffer if a filled buffer is available,
 * otherwise waits until a buffer is filled.
 */
ADI_I2C_RESULT adi_i2c_GetTxBuffer (
                    ADI_I2C_HANDLE   const   hDevice,
                    void                   **ppBuffer
);

/*
 * Enable/Disable dataflow.
 */
ADI_I2C_RESULT adi_i2c_Enable (
                    ADI_I2C_HANDLE   const   hDevice,
                    bool_t           const   bEnable
);

/*
 * Write data to a I2C device (blocking).
 */
ADI_I2C_RESULT adi_i2c_Write(
    ADI_I2C_HANDLE         const hDevice,
    void                        *pBuffer,
    uint32_t               const nBufSize
);

/*
 * Read data from a I2C device (blocking).
 */
ADI_I2C_RESULT adi_i2c_Read(
    ADI_I2C_HANDLE         const hDevice,
    void                        *pBuffer,
    uint32_t               const nBufSize
);

/*
 * Set the I2C serial clock bit rate.
 */
ADI_I2C_RESULT adi_i2c_SetBitRate(
    ADI_I2C_HANDLE         const hDevice,
    uint16_t               const BitRate
);

/*
 * Set the I2C duty cycle.
 */
ADI_I2C_RESULT adi_i2c_SetDutyCycle(
    ADI_I2C_HANDLE         const hDevice,
    uint16_t               const DutyCycle
);

/*
 * Set the I2C device address.
 */
ADI_I2C_RESULT adi_i2c_SetHardwareAddress(
    ADI_I2C_HANDLE         const hDevice,
    uint16_t               const Address
);

/*
 * Set the I2C device address size
 */
ADI_I2C_RESULT adi_i2c_SetHWAddressWidth (
    ADI_I2C_HANDLE         const hDevice,
    ADI_I2C_HWADDR_WIDTH   const eAddrWidth
);
/*
 * Enable slave general call address matching.
 */
ADI_I2C_RESULT adi_i2c_EnableGeneralCall (
    ADI_I2C_HANDLE        const hDevice,
    bool_t                const bEnable
);

/*
 * Set the alternate Device ID required for Hardware General Call
 */
ADI_I2C_RESULT adi_i2c_SetAlternateDevID(
    ADI_I2C_HANDLE         const hDevice,
    uint8_t                const nDeviceID
);

/* Enable/Disable internal loopback between the master and the slave */
ADI_I2C_RESULT adi_i2c_EnableInternalLoopback (
                                               ADI_I2C_HANDLE   const hDevice,
                                               bool_t           const bEnable
                                               );

/* Sets the maximum automatic SCL clock stretching */
ADI_I2C_RESULT adi_i2c_SetAutoStretch (
                                       ADI_I2C_HANDLE  const hDevice,
                                       uint8_t         const nExpBitTimes
                                       );

#if ((ADI_I2C_CFG_ENABLE_DMA_SUPPORT == 1) && (ADI_I2C_CFG_ENABLE_PIO_SUPPORT == 1))
/* Enable/Disable DMA for transfering data */
ADI_I2C_RESULT adi_i2c_EnableDMA (
                                  ADI_I2C_HANDLE   const hDevice,
                                  bool_t           const bEnable
                                  );
#endif

/* Get all the global events that occurred */
ADI_I2C_RESULT adi_i2c_GetEvents (
                                  ADI_I2C_HANDLE   const   hDevice,
                                  uint32_t*        const   pnEvents
                                  );

/* Return a flag to determine whether a global event is available or not */
ADI_I2C_RESULT adi_i2c_IsEventAvailable (
                                         ADI_I2C_HANDLE   const hDevice,
                                         bool_t*          const pbAvailable
                                         );

#ifdef __cplusplus
}
#endif

/**@}*/

#endif /* __ADI_I2C_V1_H__ */
